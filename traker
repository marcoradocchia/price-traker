#!/usr/bin/env python

from argparse import ArgumentParser
from bs4 import BeautifulSoup
from configparser import ConfigParser
from datetime import date
from email.message import EmailMessage
from json import dumps as json_dumps
from json import loads as json_loads
from os import mkdir
from os.path import expanduser, isdir, isfile, join
from re import compile, match, IGNORECASE
from requests import get
from smtplib import SMTP_SSL
from ssl import create_default_context
from sys import argv
from sys import exit as sys_exit

XDG_CONFIG = expanduser("~/.config/price-traker")
XDG_DATA = expanduser("~/.local/share/price-traker")
CONFIG_FILE = join(XDG_CONFIG, "config")
PRODUCT_LIST_FILE = join(XDG_DATA, "product_list.json")

# UTILS
def check_mail_addr(mail: str) -> None:
    if not match(r"^[A-Za-z0-9\.\+_-]+@[A-Za-z0-9\._-]+\.[a-zA-Z]*$", mail):
        sys_exit(f"ERROR: '{mail}' is not a valid mail address")


def check_smtp_server(server_url: str) -> None:
    if not match(r"^[A-Za-z0-9\.\+_-]+\.[a-zA-Z]*$", server_url):
        sys_exit(f"ERROR: '{server_url}' is not a valid SMTP server URL")


def check_url(url: str) -> None:
    url_regex = compile(
        r"^(?:http|ftp)s?://"  # http:// or https://
        r"(?:(?:[A-Z0-9](?:[A-Z0-9-]{0,61}[A-Z0-9])?\.)+(?:[A-Z]{2,6}\.?|[A-Z0-9-]{2,}\.?)|"  # domain...
        r"localhost|"  # localhost...
        r"\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3})"  # ...or ip
        r"(?::\d+)?"  # optional port
        r"(?:/?|[/?]\S+)$",
        IGNORECASE,
    )
    if not match(url_regex, url):
        sys_exit(f"ERROR: '{url}' is not a valid URL")


def get_date() -> str:
    return f"{date.today().year}-{date.today().month}-{date.today().day}"


def write_list(products: list) -> None:
    with open(PRODUCT_LIST_FILE, 'w+') as products_file:
        products_file.write(json_dumps(products, indent=4))


def get_config() -> dict:
    # check for configuration file, if not found then exit
    if not isfile(CONFIG_FILE):
        sys_exit(
            "ERROR: Configuration file not found."
            f"please create configuration file at {CONFIG_FILE}"
        )
    config = ConfigParser()
    config.read(CONFIG_FILE)
    config_opts = {}
    if 'mail' in config.sections():
        smtp_server = config.get('mail', 'smtp_server')
        # check server url before continue
        check_smtp_server(smtp_server)
        # check mail address before continue
        notifier_addr = config.get('mail', 'notifier_addr')
        check_mail_addr(notifier_addr)
        config_opts['mail'] = {}
        config_opts['mail']['smtp_server'] = smtp_server
        config_opts['mail']['port'] = config.get('mail', 'port')
        config_opts['mail']['notifier_addr'] = notifier_addr
        config_opts['mail']['notifier_psw'] = config.get('mail', 'notifier_psw')
    return config_opts


def get_page(url: str) -> BeautifulSoup:
    request_headers = {
        'User-agent': 'Mozilla/5.0 (Windows NT 6.1; WOW64) App\
        leWebKit/535.11 (KHTML, like Gecko) Chrome/17.0.963.56 Safari/535.11'
    }
    try:
        page = BeautifulSoup(get(url, headers=request_headers).text, 'lxml')
    except:
        sys_exit(f"ERROR: Unable to load the page '{url}'")
    return page


def get_price(page: BeautifulSoup) -> float:
    price = page.find(class_='a-offscreen') # amazon price
    return float(price.text.strip('\n')[:-1].replace(',', '.'))


def get_list() -> list:
    # check for data file
    if not isfile(PRODUCT_LIST_FILE):
        # check for data directory, if doesn't exist try to create one
        if not isdir(XDG_DATA):
            try:
                mkdir(XDG_DATA)
            except:
                sys_exit(f"ERROR: unable to create directory {XDG_DATA}")
        write_list(products=[])
        return [] # if file didn't exist, no need to read it
    with open(PRODUCT_LIST_FILE, 'r') as products_file:
        product_list = json_loads(products_file.read())
    return product_list


# NOTIFICATIONS
def send_notification(mail_addr: str, mail_body: str) -> None:
    config_opts = get_config()
    if 'mail' in config_opts:
        mail = EmailMessage()
        mail['Subject'] = "Price Traker: lower price detected"
        mail['To'] = mail_addr
        mail['From'] = config_opts['mail']['notifier_addr']
        mail.set_content(mail_body)
        with SMTP_SSL(
            config_opts['mail']['smtp_server'],
            config_opts['mail']['port'],
            context=create_default_context(),
        ) as server:
            server.login(
                config_opts['mail']['notifier_addr'],
                config_opts['mail']['notifier_psw'],
            )
            server.send_message(mail)


# FEATURES
def insert_product(url: str, mail_addr: str) -> None:
    product_list = get_list()
    # look for product in product_list
    for product in product_list:
        if (product['url'] == url):
            if mail_addr in product['followers']:
                # if mail_addr already in followers array, exit
                sys_exit(
                    f"WARNING: '{mail_addr}' already tracking "
                    f"'{product['title'][:50]}...'.\n"
                    f"No further actions needed."
                )
            else:
                # product already in product_list but mail_addr not in followers
                # add mail_addr to followers and exit
                product['followers'].append(mail_addr)
                write_list(products=product_list)
                return
    # if product not found in product_list, add new entry to product_list
    page = get_page(url=url)
    product_list.append(
        {
            'url': url,
            'title': page.find(id='productTitle').text.strip(' \n'),
            'followers': [mail_addr],
            'prices': [
                {
                    'date': get_date(),
                    'price': get_price(page)
                }
            ],
        }
    )
    # write updated product_list to PRODUCT_LIST_FILE
    write_list(products=product_list)


def list_products() -> None:
    product_list = get_list()
    for product in product_list:
        print(
            f"{product['title'][:50]}...\n"
            f"├── {product['prices'][-1]['price']}€\n"
            f"├── {product['prices'][-1]['date']}\n"
            f"└── {', '.join(product['followers'])}\n"
        )


def remove_product(substr: str) -> None:
    product_list = get_list()
    for index, product in enumerate(product_list):
        if substr.lower() in product['title'].lower():
            if input(f"Remove '{product['title']}'? [y/N]: ").lower() == 'y':
                product_list.pop(index)
                write_list(products=product_list)


def update_prices() -> None:
    product_list = get_list()
    today = get_date()
    # exit on empty product_list
    if len(product_list) == 0:
        sys_exit("WARNING: no products are being tracked.")
    # notification_queue object structure:
    # {
    #   'mail_addr1': 'mail_body1',
    #   'mail_addr2': 'mail_body2',
    # }
    notification_queue = {}
    for product in product_list:
        # if the last price update is today,
        # ignore updating price for that product
        if product['prices'][-1]['date'] == today:
            continue
        page = get_page(url=product['url'])
        today_price = get_price(page)
        product['prices'].append(
            {
                'date': today,
                'price': today_price
            }
        )
        prev_price = product['prices'][-2]['price']
        price_delta = round(today_price - prev_price, 2)
        # if product has lower price than last check,
        # add followers to notification_queue
        if price_delta < 0:
            notification_body = (
                f"{product['title'][:50]}...\n"
                f"├── url: {product['url']}\n"
                f"├── previous price: {prev_price}€ "
                f"({product['prices'][-2]['date']})\n"
                f"├── current price: {today_price}€ ({today})\n"
                f"└── delta: {price_delta}€\n"
            )
            # for each follower of the product, append the notification_body
            # if it already exists in the notification_queue,
            # create an instance otherwhise
            for follower in product['followers']:
                if follower in notification_queue:
                    notification_queue[follower] += notification_body
                else:
                    notification_queue[follower] = notification_body
    # write updated product_list to PRODUCT_LIST_FILE
    # write_list(products=product_list) # TODO uncomment this
    # mail
    for mail_addr in notification_queue:
        send_notification(
            mail_addr=mail_addr,
            mail_body=notification_queue[mail_addr],
        )


# MAIN
def main() -> None:
    # TODO format usage
    argparser = ArgumentParser()
    argparser.add_argument(
        '-u',
        '--update',
        action='store_true',
        help='update prices for every product'
    )
    argparser.add_argument(
        '-i',
        '--insert',
        type=str,
        nargs=2,
        help='insert new product to the traking list given product \
            URL and notification mail address',
    )
    argparser.add_argument(
        '-r',
        '--remove',
        type=str,
        help='remove product from the traking list'
    )
    argparser.add_argument(
        '-l',
        '--list',
        action='store_true',
        help='list all the tracked products'
    )

    if len(argv) == 1:  # If no argument is given print help and exit
        argparser.print_help()
        argparser.exit(status=0)

    args = argparser.parse_args()

    if args.remove is not None:
        remove_product(args.remove)
    if args.insert is not None:
        check_url(args.insert[0])
        check_mail_addr(args.insert[1])
        insert_product(url=args.insert[0], mail_addr=args.insert[1])
    if args.update:
        update_prices()
    if args.list:
        list_products()


if __name__ == '__main__':
    main()
