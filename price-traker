#!/usr/bin/python

from argparse import ArgumentParser
from bs4 import BeautifulSoup
from configparser import ConfigParser
from crontab import CronTab
from datetime import date
from email.message import EmailMessage
from json import loads as json_loads
from json import dumps as json_dumps
from matplotlib import dates as mpl_dates
from matplotlib import pyplot as plt
from matplotlib.ticker import MultipleLocator
from requests import get
from smtplib import SMTP_SSL
from ssl import create_default_context
from sys import argv
from sys import exit as sys_exit
from re import match, IGNORECASE
from re import compile as re_compile
from os.path import expanduser, isfile

# CONSTANTS ------------------------------------------------------------------ #
USR_CONFIG_DIR = expanduser('~') + '/.config/price-traker'

# UTILS ---------------------------------------------------------------------- #
def check_mail_address(mail: str) -> None:
    if not match(r'^[A-Za-z0-9\.\+_-]+@[A-Za-z0-9\._-]+\.[a-zA-Z]*$', mail):
        sys_exit(f'ERROR: \"{mail}\" is not a valid mail address')
    return

def check_smtp_server(server_url: str) -> None:
    if not match(r'^[A-Za-z0-9\.\+_-]+\.[a-zA-Z]*$', server_url):
        sys_exit(f'ERROR: \"{server_url}\" is not a valid SMTP server URL')
    return

def check_url(url: str) -> None:
    url_regex = re_compile(
        r'^(?:http|ftp)s?://' # http:// or https://
        r'(?:(?:[A-Z0-9](?:[A-Z0-9-]{0,61}[A-Z0-9])?\.)+(?:[A-Z]{2,6}\.?|[A-Z0-9-]{2,}\.?)|' #domain...
        r'localhost|' #localhost...
        r'\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3})' # ...or ip
        r'(?::\d+)?' # optional port
        r'(?:/?|[/?]\S+)$',
        IGNORECASE
    )
    if not match(url_regex, url):
        sys_exit(f'ERROR: \"{url}\" is not a valid URL')
    return

def get_date() -> str:
    return f'{date.today().year}-{date.today().month}-{date.today().day}'

def write_file(products: list) -> None:
    with open(USR_CONFIG_DIR + '/products.json', 'w+') as products_file:
        products_file.write(json_dumps(products, indent=4))
    return

def get_config() -> dict:
    config_file = USR_CONFIG_DIR + '/config'
    if not isfile(config_file): return # no config file found
    config = ConfigParser()
    config.read(config_file)
    config_opts = {}
    if 'mail' in config.sections():
        smtp_server = config.get('mail', 'smtp_server')
        check_smtp_server(smtp_server)
        sender_mail_address = config.get('mail', 'sender_mail_address')
        check_mail_address(sender_mail_address)
        config_opts["mail"] = {}
        config_opts["mail"]["smtp_server"] = smtp_server
        config_opts["mail"]["port"] = config.get('mail', 'port')
        config_opts["mail"]["sender_mail_address"] = sender_mail_address
        config_opts["mail"]["sender_mail_psw"] = config.get(
            'mail',
            'sender_mail_psw'
        )
    return config_opts

def get_page(url: str) -> 'bs4.BeautifulSoup':
    request_headers = { "User-agent": 'Mozilla/5.0 (Windows NT 6.1; WOW64) App\
        leWebKit/535.11 (KHTML, like Gecko) Chrome/17.0.963.56 Safari/535.11' }
    try:
        page = BeautifulSoup(get(url, headers=request_headers).text, 'lxml')
    except:
        sys_exit(f'ERROR: Unable to load the page \"{url}\"')
    return page

def get_price(page: 'bs4.BeautifulSoup') -> float:
    priceblock = page.find(id='priceblock_ourprice') # check for AMAZON standard price
    if not priceblock:
        priceblock = page.find(id='priceblock_dealprice') # if AMAZON standard price doesn't exists check for deal price
    return float(priceblock.text.strip('\n')[:-1].replace(',', '.'))

def get_products() -> list:
    with open(USR_CONFIG_DIR + '/products.json', 'r') as products_file:
        products = json_loads(products_file.read())
    return products


# NOTIFICATIONS -------------------------------------------------------------- #
def send_notification(notification_mail_address: dict, notification_msg: str) -> None:
    config_opts = get_config()
    if 'mail' in config_opts:
        msg = EmailMessage()
        msg["Subject"] = 'Price Traker Update'
        msg["To"] = notification_mail_address
        msg["From"] = config_opts["mail"]["sender_mail_address"]
        msg.set_content(notification_msg)
        with SMTP_SSL(
                config_opts["mail"]["smtp_server"],
                config_opts["mail"]["port"],
                context=create_default_context()
            ) as server:
            server.login(
                config_opts["mail"]["sender_mail_address"],
                config_opts["mail"]["sender_mail_psw"]
            )
            server.send_message(msg)
    return


# FEATURES ------------------------------------------------------------------- #
def insert_product(url: str, notification_mail_address: str) -> None:
    products_list = get_products()
    for product in products_list:
        if product["url"] == url and product["notification_mail_address"]\
                == notification_mail_address:
            sys_exit('WARNING: this URL is already in the traking list')
    page = get_page(url=url)
    products_list.append(
        {
            "url": url,
            "title": page.find(id='productTitle').text.strip('\n'),
            "notification_mail_address": notification_mail_address,
            "prices": [
                {
                    "date": get_date(),
                    "price": get_price(page)
                }
            ]
        }
    )
    write_file(products_list)
    return

def list_products() -> None:
    products_list = get_products()
    for index, product in enumerate(products_list):
        print(f'{index+1}. {product["title"]} -> {product["prices"][-1]["price"]}€ ({product["prices"][-1]["date"]}) {product["notification_mail_address"]}')

def plot_prices() -> None:
    plt.style.use('ggplot')
    plt.xlabel('Date')
    plt.ylabel('Price (€)')
    plt.title('Price Traker')
    products_list = get_products()
    for product in products_list:
        x = []; y = []
        for prices in product["prices"]:
            date_ = prices["date"].split('-')
            x.append(date(int(date_[0]), int(date_[1]), int(date_[2])))
            y.append(prices["price"])
        plt.plot_date(
            x,
            y,
            label=product["title"][:30],
            linestyle='solid'
        )
    plt.gcf().autofmt_xdate()
    date_format = mpl_dates.DateFormatter('%b, %d')
    ax = plt.gca()
    ax.yaxis.grid(True, 'minor')
    ax.yaxis.set_major_locator(MultipleLocator(10))
    ax.yaxis.set_minor_locator(MultipleLocator(5))
    ax.xaxis.set_major_locator(mpl_dates.DayLocator(interval=1)) #TODO: when a lot of data is displayed there's overpopulation
    ax.xaxis.set_major_formatter(date_format)
    plt.legend()
    plt.tight_layout()
    plt.show()
    return

def remove_product(substr: str) -> None:
    products_list = get_products()
    for index, product in enumerate(products_list):
        if substr.lower() in product["title"].lower():
            if input(f'Are you sure you want to remove \'{product["title"]}\'? [Y/n]: ').lower() == 'y':
                products_list.pop(index)
                write_file(products_list)
    return

def schedule_cronjob(hour: int) -> None:
    def check_existing_job(cron: 'crontab.CronTab') -> bool:
        found = cron.find_command('price-traker')
        for job in found:
            if 'price-traker --update' in str(job):
                return True
        return False
    cron = CronTab(user=True)
    if not check_existing_job(cron):
        job = cron.new(
            command='/home/radocchia/code/python/price-traker/price-traker --update', #TODO change path here
            comment='Updates price-traker items prices'
        )
        job.minute.on(00)
        job.hour.on(hour)
        cron.write()
    return

def update_prices() -> None:
    products_list = get_products()
    notification_mailing_list = {}
    for product in products_list:
        # if the last price update is today, ignore updating for that product
        if product["prices"][-1]["date"] == get_date(): continue
        page = get_page(url=product["url"])
        current_price = get_price(page)
        current_date = get_date()
        product["prices"].append({"date": current_date, "price": current_price})
        previous_price = product["prices"][-2]["price"]
        notification_mail_address = product["notification_mail_address"]
        # sends notification if a product has lower price than last check
        if current_price < previous_price:
            if notification_mail_address not in notification_mailing_list:
                notification_mailing_list[f"{notification_mail_address}"] = ""
            delta = round(current_price - previous_price, 2)
            notification_mailing_list[f"{notification_mail_address}"] += f"""\
URL: {product["url"]}
Product: {product["title"]}
Previus price: {previous_price}€ ({product["prices"][-2]["date"]})
Current price: {current_price}€ ({current_date})
Delta: {delta}€
---
"""
    for notification_mail_address in notification_mailing_list:
        send_notification(
            notification_mail_address=notification_mail_address,
            notification_msg=notification_mailing_list[f"{notification_mail_address}"]
        )
    write_file(products=products_list)
    return

# MAIN ---------------------------------------------------------------------- #
def main() -> None:
    #TODO format usage
    argparser = ArgumentParser()

    argparser.add_argument(
        '-u', '--update',
        action='store_true',
        help='Updates prices for every product'
    )
    argparser.add_argument(
        '-i', '--insert',
        type=str,
        nargs=2,
        help='Insert new product to the traking list given product URL and notification mail address'
    )
    argparser.add_argument(
        '-s', '--schedule',
        type=int,
        nargs=1,
        help='Autoupdate prices daily (cron) at specified hour of day (24h format)'
    )
    argparser.add_argument(
        '-r', '--remove',
        type=str,
        help='Remove product from the traking list'
    )
    argparser.add_argument(
        '-p', '--plot',
        action='store_true',
        help='Updates prices for every product'
    )
    argparser.add_argument(
        '-l', '--list',
        action='store_true',
        help='Lists all the tracked products'
    )

    if len(argv) == 1: # If no argument is given print help and exit
        argparser.print_help()
        argparser.exit(status=0)

    args = argparser.parse_args()

    if args.remove is not None:
        remove_product(args.remove)
    if args.insert is not None:
        check_url(args.insert[0])
        check_mail_address(args.insert[1])
        insert_product(
            url=args.insert[0],
            notification_mail_address=args.insert[1]
        )
    if args.update:
        update_prices()
    if args.plot:
        plot_prices()
    if args.list:
        list_products()
    if args.schedule is not None:
        hour = args.schedule[0]
        if hour < 0 or hour > 23:
            sys_exit('ERROR: please insert a valid argument; hour of day must be a number between 0 and 23')
        schedule_cronjob(hour=hour)
    return


if __name__ == '__main__':
    main()



# TODO: make notification_mail_address in json a list so multiple mail
# addresses can be notified about the same product
