#!/usr/bin/python

import argparse

from bs4 import BeautifulSoup
from configparser import ConfigParser
from crontab import CronTab
from datetime import date
from email.message import EmailMessage
from json import loads as json_loads
from json import dumps as json_dumps
from matplotlib import dates as mpl_dates
from matplotlib import pyplot as plt
from matplotlib.ticker import MultipleLocator
from requests import get
from smtplib import SMTP_SSL
from ssl import create_default_context
from sys import argv
from sys import exit as sys_exit
from re import match, IGNORECASE
from re import compile as re_compile
from os.path import expanduser, isfile

# GLOBAL VARIABLES ----------------------------------------------------------- #
HOME = expanduser('~')
USR_CONFIG_DIR = HOME + '/.config/price-traker'
AMAZON_DOMAIN = 'https://www.amazon'

# UTILS ---------------------------------------------------------------------- #
def check_mail_address(mail: str) -> None:
    if not match(r'^[A-Za-z0-9\.\+_-]+@[A-Za-z0-9\._-]+\.[a-zA-Z]*$', mail):
        sys_exit(f'ERROR: \"{mail}\" is not a valid mail address')
    return

def check_smtp_server(server_url: str) -> None:
    if not match(r'^[A-Za-z0-9\.\+_-]+\.[a-zA-Z]*$', server_url):
        sys_exit(f'ERROR: \"{server_url}\" is not a valid SMTP server URL')
    return

def check_url(url: str) -> None:
    url_regex = re_compile(
        r'^(?:http|ftp)s?://' # http:// or https://
        r'(?:(?:[A-Z0-9](?:[A-Z0-9-]{0,61}[A-Z0-9])?\.)+(?:[A-Z]{2,6}\.?|[A-Z0-9-]{2,}\.?)|' #domain...
        r'localhost|' #localhost...
        r'\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3})' # ...or ip
        r'(?::\d+)?' # optional port
        r'(?:/?|[/?]\S+)$',
        IGNORECASE
    )
    if not match(url_regex, url):
        sys_exit(f'ERROR: \"{url}\" is not a valid URL')
    return

def get_date() -> str:
    return f'{date.today().year}-{date.today().month}-{date.today().day}'

def write_file(products: list) -> None:
    with open(USR_CONFIG_DIR + '/products.json', 'w+') as products_file:
        products_file.write(json_dumps(products, indent=4))
    return

def get_config() -> dict:
    config_file = USR_CONFIG_DIR + '/config'
    if not isfile(config_file): return # no config file found
    config = ConfigParser()
    config.read(config_file)
    config_opts = {}
    if 'mail' in config.sections():
        smtp_server = config.get('mail', 'smtp_server')
        check_smtp_server(smtp_server)
        sender_mail_address = config.get('mail', 'sender_mail_address')
        check_mail_address(sender_mail_address)
        config_opts["mail"] = {}
        config_opts["mail"]["smtp_server"] = smtp_server
        config_opts["mail"]["port"] = config.get('mail', 'port')
        config_opts["mail"]["sender_mail_address"] = sender_mail_address
        config_opts["mail"]["sender_mail_psw"] = config.get(
            'mail',
            'sender_mail_psw'
        )
    return config_opts

def get_page(url: str) -> 'bs4.BeautifulSoup':
    request_headers = { "User-agent": 'Mozilla/5.0 (Windows NT 6.1; WOW64) App\
        leWebKit/535.11 (KHTML, like Gecko) Chrome/17.0.963.56 Safari/535.11' }
    try:
        page = BeautifulSoup(get(url, headers=request_headers).text, 'lxml')
    except:
        sys_exit(f'ERROR: Unable to load the page \"{url}\"')
    return page

def get_products() -> list:
    with open(USR_CONFIG_DIR + '/products.json', 'r') as products_file:
        products = json_loads(products_file.read())
    return products


# NOTIFICATIONS -------------------------------------------------------------- #
def send_notification(notification_mail_address: dict, notification_msg_content: str) -> None:
    config_opts = get_config()
    if 'mail' in config_opts:
        msg = EmailMessage()
        msg["Subject"] = 'Price Traker Update'
        msg["To"] = notification_mail_address
        msg["From"] = config_opts["mail"]["sender_mail_address"]
        msg.set_content(notification_msg_content)
        with SMTP_SSL(
                config_opts["mail"]["smtp_server"],
                config_opts["mail"]["port"],
                context=create_default_context()
            ) as server:
            server.login(
                config_opts["mail"]["sender_mail_address"],
                config_opts["mail"]["sender_mail_psw"]
            )
            server.send_message(msg)
    return


# FEATURES ------------------------------------------------------------------- #
def insert_product(url: str, notification_mail_address: str) -> None:
    products_list = get_products()
    for product in products_list:
        if product["url"] == url and product["notification_mail_address"]\
                == notification_mail_address:
            sys_exit('WARNING: this URL is already in the traking list')
    page = get_page(url=url)
    products_list.append(
        {
            "url": url,
            "title": page.find(id='productTitle').text.strip('\n'),
            "notification_mail_address": notification_mail_address,
            "prices": [
                {
                    "date": get_date(),
                    "price": float(page.find(id='priceblock_ourprice').text\
                        .strip('\n')[:-1].replace(',', '.'))
                }
            ]
        }
    )
    write_file(products_list)
    return

def list_products() -> None:
    products_list = get_products()
    for index, product in enumerate(products_list):
        print(f'{index+1}. {product["title"]}')

def plot_prices() -> None:
    plt.style.use('ggplot')
    plt.xlabel('Date')
    plt.ylabel('Price (€)')
    plt.title('Price Traker')
    products_list = get_products()
    for product in products_list:
        x = []; y = []
        for prices in product["prices"]:
            date_ = prices["date"].split('-')
            x.append(date(int(date_[0]), int(date_[1]), int(date_[2])))
            y.append(prices["price"])
        plt.plot_date(
            x,
            y,
            label=product["title"][:30],
            linestyle='solid'
        )
    plt.gcf().autofmt_xdate()
    date_format = mpl_dates.DateFormatter('%b, %d')
    ax = plt.gca()
    ax.yaxis.grid(True, 'minor')
    ax.yaxis.set_major_locator(MultipleLocator(10))
    ax.yaxis.set_minor_locator(MultipleLocator(5))
    ax.xaxis.set_major_locator(mpl_dates.DayLocator(interval=1))
    ax.xaxis.set_major_formatter(date_format)
    plt.legend()
    plt.tight_layout()
    plt.show()
    return

def remove_product(substr: str) -> None:
    products_list = get_products()
    for index, product in enumerate(products_list):
        if substr.lower() in product["title"].lower():
            if input(f'Are you sure you want to remove \'{product["title"]}\'? [Y/n]: ').lower() == 'y':
                products_list.pop(index)
                write_file(products_list)
    return

def schedule_cronjob(hour: int) -> None:
    def check_existing_job(cron: 'crontab.CronTab') -> bool:
        found = cron.find_command('price-traker')
        for job in found:
            if 'price-traker --update' in str(job):
                return True
        return False
    cron = CronTab(user=True)
    if not check_existing_job(cron):
        job = cron.new(
            command='/home/radocchia/code/python/price-traker/price-traker --update', #TODO change path here
            comment='Updates price-traker items prices'
        )
        # TODO correct cronjob
        job.minute.on(00)
        job.hour.on(hour)
        cron.write()
    return

def update_prices() -> None:
    products_list = get_products()
    notification_msg_content = ""
    for product in products_list:
        # if the last price update is today, ignore updating for that product
        if product["prices"][-1]["date"] == get_date(): continue
        page = get_page(url=product["url"])
        current_price = float(page.find(id='priceblock_ourprice').text.\
            strip('\n')[:-1].replace(',', '.'))
        current_date = get_date()
        product["prices"].append({"date": current_date, "price": current_price})
        previous_price = product["prices"][-2]["price"]
        # sends notification if a product has lower price than last check
        if current_price < previous_price:
            delta = round(product_current_price - product_previous_price, 2)
            notification_msg_content += """\
URL: {product["url"]}
Product: {product["title"]}
Current price: {current_price}€ ({current_date})
Previus price: {previous_price}€ ({product["prices"][-2]["date"]})
Delta: {delta}€
-----------------------------------------------------------------
"""
    if notification_msg_content != "":
        send_notification(
            product=product,
            notification_msg_content=notification_msg_content
        )
    write_file(products=products_list)
    return

# MAIN ---------------------------------------------------------------------- #
def main() -> None:
    #TODO format usage
    argparser = argparse.ArgumentParser()

    argparser.add_argument(
        '-u', '--update',
        action='store_true',
        help='Updates prices for every product'
    )
    argparser.add_argument(
        '-i', '--insert',
        type=str,
        nargs=2,
        help='Insert new product to the traking list given product URL and notification mail address'
    )
    argparser.add_argument(
        '-s', '--schedule',
        type=int,
        nargs=1,
        help='Autoupdate prices daily (cron) at specified hour of day (24h format)'
    )
    argparser.add_argument(
        '-r', '--remove',
        type=str,
        help='Remove product from the traking list'
    )
    argparser.add_argument(
        '-p', '--plot',
        action='store_true',
        help='Updates prices for every product'
    )
    argparser.add_argument(
        '-l', '--list',
        action='store_true',
        help='Lists all the tracked products'
    )
    # exclusives = argparser.add_mutually_exclusive_group()
    # exclusives.add_argument(
        # '-q', '--quiet',
        # action='store_true',
        # help='No output shown'
    # )

    if len(argv) == 1: # If no argument is given print help and exit
        argparser.print_help()
        argparser.exit(status=0)

    args = argparser.parse_args()

    if args.remove is not None:
        remove_product(args.remove)
    if args.insert is not None:
        check_url(args.insert[0])
        check_mail_address(args.insert[1])
        insert_product(
            url=args.insert[0],
            notification_mail_address=args.insert[1]
        )
    if args.update:
        update_prices()
    if args.plot:
        plot_prices()
    if args.list:
        list_products()
    if args.schedule is not None:
        hour = args.schedule[0]
        if hour < 0 or hour > 23:
            sys_exit('ERROR: please insert a valid argument; hour of day must be a number between 0 and 23')
        schedule_cronjob(hour=hour)
    return


if __name__ == '__main__':
    main()



# TODO: make notification_mail_address in json a list so multiple mail
# addresses can be notified about the same product
